package codegen

import (
	"fmt"
	"strconv"
	"strings"

	"goa.design/goa/codegen"
	"goa.design/goa/expr"
)

// protoBufMessageName returns the protocol buffer message name of the given
// attribute type.
func protoBufMessageName(att *expr.AttributeExpr, s *codegen.NameScope) string {
	return protoBufFullMessageName(att, "", s)
}

// protoBufFullMessageName returns the protocol buffer message name of the
// given user type qualified with the given package name if applicable.
func protoBufFullMessageName(att *expr.AttributeExpr, pkg string, s *codegen.NameScope) string {
	switch actual := att.Type.(type) {
	case expr.UserType:
		n := s.HashedUnique(actual, protoBufify(actual.Name(), true), "")
		if pkg == "" {
			return n
		}
		return pkg + "." + n
	case expr.CompositeExpr:
		return protoBufFullMessageName(actual.Attribute(), pkg, s)
	default:
		panic(fmt.Sprintf("data type is not a user type %T", actual)) // bug
	}
}

// protoBufGoFullTypeName returns the protocol buffer type name for the given
// attribute generated after compiling the proto file (in *.pb.go).
func protoBufGoTypeName(att *expr.AttributeExpr, s *codegen.NameScope) string {
	return protoBufGoFullTypeName(att, "", s)
}

// protoBufGoFullTypeName returns the protocol buffer type name qualified with
// the given package name for the given attribute generated after compiling
// the proto file (in *.pb.go).
func protoBufGoFullTypeName(att *expr.AttributeExpr, pkg string, s *codegen.NameScope) string {
	switch actual := att.Type.(type) {
	case expr.UserType, expr.CompositeExpr:
		return protoBufFullMessageName(att, pkg, s)
	case expr.Primitive:
		return protoBufNativeGoTypeName(actual)
	case *expr.Array:
		return "[]" + protoBufGoFullTypeRef(actual.ElemType, pkg, s)
	case *expr.Map:
		return fmt.Sprintf("map[%s]%s",
			protoBufGoFullTypeRef(actual.KeyType, pkg, s),
			protoBufGoFullTypeRef(actual.ElemType, pkg, s))
	case *expr.Object:
		return s.GoTypeDef(att, false)
	default:
		panic(fmt.Sprintf("unknown data type %T", actual)) // bug
	}
}

// protoBufMessageDef returns the protocol buffer code that defines a message
// which matches the data structure definition (the part that comes after
// `message foo`). The message is defined using the proto3 syntax.
// NOTE: protocol buffer does not have native support for multi-dimensional
// arrays or array of maps or map of maps or map of arrays. In such cases,
// goa generates a user type that contains the inner array or map element
// types. See https://github.com/protocolbuffers/protobuf/issues/4596.
//
// For example:
//
// Type("Response", func() {
//   "items", ArrayOf(ArrayOf(ArrayOf(Int)))
// })
//
// will get transformed to message
//
// message Response {
//   repeated ArrayOfArrayOfInt items = 1;
// }
//
// message ArraOfArrayOfInt {
//   repeated ArrayOfInt field = 1;
// }
//
// message ArrayOfInt {
//   repeated int field = 1;
// }
func protoBufMessageDef(att *expr.AttributeExpr, s *codegen.NameScope) string {
	switch actual := att.Type.(type) {
	case expr.Primitive:
		return protoBufNativeMessageTypeName(att.Type)
	case *expr.Array:
		return "repeated " + innerTypeName(actual.ElemType, s)
	case *expr.Map:
		return fmt.Sprintf("map<%s, %s>", innerTypeName(actual.KeyType, s), innerTypeName(actual.ElemType, s))
	case expr.UserType:
		return protoBufMessageName(att, s)
	case *expr.Object:
		var ss []string
		ss = append(ss, " {")
		for _, nat := range *actual {
			var (
				fn   string
				fnum uint64
				typ  string
				desc string
			)
			{
				fn = codegen.SnakeCase(protoBufify(nat.Name, false))
				fnum = rpcTag(nat.Attribute)
				typ = protoBufMessageDef(nat.Attribute, s)
				if nat.Attribute.Description != "" {
					desc = codegen.Comment(nat.Attribute.Description) + "\n\t"
				}
			}
			ss = append(ss, fmt.Sprintf("\t%s%s %s = %d;", desc, typ, fn, fnum))
		}
		ss = append(ss, "}")
		return strings.Join(ss, "\n")
	default:
		panic(fmt.Sprintf("unknown data type %T", actual)) // bug
	}
}

// protoBufGoTypeRef returns the Go code that refers to the Go type generated
// by compiling the protocol buffer (in *.pb.go) for the given attribute.
func protoBufGoTypeRef(att *expr.AttributeExpr, s *codegen.NameScope) string {
	name := innerTypeName(att, s)
	if expr.IsObject(att.Type) {
		return "*" + name
	}
	return name
}

// protoBufGoFullTypeRef returns the Go code qualified with package name that
// refers to the Go type generated by compiling the protocol buffer
// (in *.pb.go) for the given attribute.
func protoBufGoFullTypeRef(att *expr.AttributeExpr, pkg string, s *codegen.NameScope) string {
	name := protoBufGoFullTypeName(att, pkg, s)
	if expr.IsObject(att.Type) {
		return "*" + name
	}
	return name
}

// protoBufify makes a valid protocol buffer identifier out of any string.
// It does that by removing any non letter and non digit character and by
// making sure the first character is a letter or "_". protoBufify produces a
// "CamelCase" version of the string.
//
// If firstUpper is true the first character of the identifier is uppercase
// otherwise it's lowercase.
func protoBufify(str string, firstUpper bool) string {
	// Optimize trivial case
	if str == "" {
		return ""
	}

	// Remove optional suffix that defines corresponding transport specific
	// name.
	idx := strings.Index(str, ":")
	if idx > 0 {
		str = str[:idx]
	}

	str = codegen.CamelCase(str, firstUpper, false)
	if str == "" {
		// All characters are invalid. Produce a default value.
		if firstUpper {
			return "Val"
		}
		return "val"
	}
	return fixReservedProtoBuf(str)
}

// protoBufifyAtt honors any struct:field:name meta set on the attribute and
// and calls protoBufify with the tag value if present or the given name
// otherwise.
func protoBufifyAtt(att *expr.AttributeExpr, name string, upper bool) string {
	if tname, ok := att.Meta["struct:field:name"]; ok {
		if len(tname) > 0 {
			name = tname[0]
		}
	}
	return protoBufify(name, upper)
}

// protoBufNativeMessageTypeName returns the protocol buffer built-in type
// corresponding to the given primitive type. It panics if t is not a
// primitive type.
func protoBufNativeMessageTypeName(t expr.DataType) string {
	switch t.Kind() {
	case expr.BooleanKind:
		return "bool"
	case expr.IntKind:
		return "sint32"
	case expr.Int32Kind:
		return "sint32"
	case expr.Int64Kind:
		return "sint64"
	case expr.UIntKind:
		return "uint32"
	case expr.UInt32Kind:
		return "uint32"
	case expr.UInt64Kind:
		return "uint64"
	case expr.Float32Kind:
		return "float"
	case expr.Float64Kind:
		return "double"
	case expr.StringKind:
		return "string"
	case expr.BytesKind:
		return "bytes"
	default:
		panic(fmt.Sprintf("cannot compute native protocol buffer type for %T", t)) // bug
	}
}

// protoBufNativeGoTypeName returns the Go type corresponding to the given
// primitive type generated by the protocol buffer compiler after compiling
// the ".proto" file (in *.pb.go).
func protoBufNativeGoTypeName(t expr.DataType) string {
	switch t.Kind() {
	case expr.BooleanKind:
		return "bool"
	case expr.IntKind:
		return "int32"
	case expr.Int32Kind:
		return "int32"
	case expr.Int64Kind:
		return "int64"
	case expr.UIntKind:
		return "uint32"
	case expr.UInt32Kind:
		return "uint32"
	case expr.UInt64Kind:
		return "uint64"
	case expr.Float32Kind:
		return "float32"
	case expr.Float64Kind:
		return "float64"
	case expr.StringKind:
		return "string"
	case expr.BytesKind:
		return "[]byte"
	default:
		panic(fmt.Sprintf("cannot compute native protocol buffer type for %T", t)) // bug
	}
}

// rpcTag returns the unique numbered RPC tag from the given attribute.
func rpcTag(a *expr.AttributeExpr) uint64 {
	var tag uint64
	if t, ok := a.Meta["rpc:tag"]; ok {
		tn, err := strconv.ParseUint(t[0], 10, 64)
		if err != nil {
			panic(err) // bug (should catch invalid field numbers in validation)
		}
		tag = tn
	}
	return tag
}

// innerTypeName traverses through the array or map type attribute and returns
// the name of the innermost type prefixed with the surrounding type names.
// It is used in constructing message field types in proto file for
// nested arrays, nested maps, array inside a map, or map inside an array.
// See https://github.com/protocolbuffers/protobuf/issues/4596.
//
// For example, given bellow attribute
//
// Type("Response", func() {
//   "items", ArrayOf(MapOf(String, ArrayOf(UserType)))
// })
//
// innerTypeName returns ArrayOfMapOfStringArrayOfUserType
func innerTypeName(att *expr.AttributeExpr, s *codegen.NameScope) string {
	var name string
	switch actual := att.Type.(type) {
	case expr.Primitive:
		return name + protoBufNativeMessageTypeName(actual)
	case expr.UserType:
		return name + protoBufMessageName(att, s)
	case *expr.Array:
		return name + "ArrayOf" + protoBufify(innerTypeName(actual.ElemType, s), true)
	case *expr.Map:
		return name + "MapOf" + protoBufify(innerTypeName(actual.KeyType, s), true) + protoBufify(innerTypeName(actual.ElemType, s), true)
	}
	return name
}

// fixReservedProtoBuf appends an underscore on to protocol buffer reserved
// keywords.
func fixReservedProtoBuf(w string) string {
	if reservedProtoBuf[w] {
		w += "_"
	}
	return w
}

var (
	// reserved protocol buffer keywords and package names
	reservedProtoBuf = map[string]bool{
		// types
		"bool":     true,
		"bytes":    true,
		"double":   true,
		"fixed32":  true,
		"fixed64":  true,
		"float":    true,
		"int32":    true,
		"int64":    true,
		"sfixed32": true,
		"sfixed64": true,
		"sint32":   true,
		"sint64":   true,
		"string":   true,
		"uint32":   true,
		"uint64":   true,

		// reserved keywords
		"enum":     true,
		"import":   true,
		"map":      true,
		"message":  true,
		"oneof":    true,
		"option":   true,
		"package":  true,
		"public":   true,
		"repeated": true,
		"reserved": true,
		"returns":  true,
		"rpc":      true,
		"service":  true,
		"syntax":   true,
	}
)

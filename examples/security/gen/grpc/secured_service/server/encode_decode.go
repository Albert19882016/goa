// Code generated by goa v2.0.0-wip, DO NOT EDIT.
//
// secured_service GRPC server encoders and decoders
//
// Command:
// $ goa gen goa.design/goa/examples/security/design -o
// $(GOPATH)/src/goa.design/goa/examples/security

package server

import (
	"context"
	"strings"

	goa "goa.design/goa"
	secured_servicepb "goa.design/goa/examples/security/gen/grpc/secured_service"
	securedservice "goa.design/goa/examples/security/gen/secured_service"
	"google.golang.org/grpc/metadata"
)

// EncodeSigninResponse encodes responses from the secured_service signin
// endpoint.
func EncodeSigninResponse(ctx context.Context, v interface{}) *secured_servicepb.SigninResponse {
	res := v.(*securedservice.Creds)
	resp := NewSigninResponse(res)
	return resp
}

// DecodeSigninRequest decodes requests sent to secured_service signin endpoint.
func DecodeSigninRequest(ctx context.Context, message *secured_servicepb.SigninRequest) (*securedservice.SigninPayload, error) {
	var (
		payload *securedservice.SigninPayload
		err     error
	)
	{
		var (
			username string
			password string
		)
		{
			md, ok := metadata.FromIncomingContext(ctx)
			if ok {
				if v := md.Get("username"); len(v) == 0 {
					err = goa.MergeErrors(err, goa.MissingFieldError("username", "metadata"))
				} else {
					username = v[0]
				}
				if v := md.Get("password"); len(v) == 0 {
					err = goa.MergeErrors(err, goa.MissingFieldError("password", "metadata"))
				} else {
					password = v[0]
				}
			}
		}
		payload = NewSigninPayload(message, username, password)
	}
	return payload, err
}

// EncodeSecureResponse encodes responses from the secured_service secure
// endpoint.
func EncodeSecureResponse(ctx context.Context, v interface{}) *secured_servicepb.SecureResponse {
	res := v.(string)
	resp := NewSecureResponse(res)
	return resp
}

// DecodeSecureRequest decodes requests sent to secured_service secure endpoint.
func DecodeSecureRequest(ctx context.Context, message *secured_servicepb.SecureRequest) (*securedservice.SecurePayload, error) {
	var (
		payload *securedservice.SecurePayload
		err     error
	)
	{
		var (
			token string
		)
		{
			md, ok := metadata.FromIncomingContext(ctx)
			if ok {
				if v := md.Get("authorization"); len(v) == 0 {
					err = goa.MergeErrors(err, goa.MissingFieldError("authorization", "metadata"))
				} else {
					token = v[0]
				}
			}
		}
		payload = NewSecurePayload(message, token)
		if strings.Contains(payload.Token, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.Token, " ", 2)[1]
			payload.Token = cred
		}
	}
	return payload, err
}

// EncodeDoublySecureResponse encodes responses from the secured_service
// doubly_secure endpoint.
func EncodeDoublySecureResponse(ctx context.Context, v interface{}) *secured_servicepb.DoublySecureResponse {
	res := v.(string)
	resp := NewDoublySecureResponse(res)
	return resp
}

// DecodeDoublySecureRequest decodes requests sent to secured_service
// doubly_secure endpoint.
func DecodeDoublySecureRequest(ctx context.Context, message *secured_servicepb.DoublySecureRequest) (*securedservice.DoublySecurePayload, error) {
	var (
		payload *securedservice.DoublySecurePayload
		err     error
	)
	{
		var (
			token string
		)
		{
			md, ok := metadata.FromIncomingContext(ctx)
			if ok {
				if v := md.Get("authorization"); len(v) == 0 {
					err = goa.MergeErrors(err, goa.MissingFieldError("authorization", "metadata"))
				} else {
					token = v[0]
				}
			}
		}
		payload = NewDoublySecurePayload(message, token)
		if strings.Contains(payload.Token, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.Token, " ", 2)[1]
			payload.Token = cred
		}
	}
	return payload, err
}

// EncodeAlsoDoublySecureResponse encodes responses from the secured_service
// also_doubly_secure endpoint.
func EncodeAlsoDoublySecureResponse(ctx context.Context, v interface{}) *secured_servicepb.AlsoDoublySecureResponse {
	res := v.(string)
	resp := NewAlsoDoublySecureResponse(res)
	return resp
}

// DecodeAlsoDoublySecureRequest decodes requests sent to secured_service
// also_doubly_secure endpoint.
func DecodeAlsoDoublySecureRequest(ctx context.Context, message *secured_servicepb.AlsoDoublySecureRequest) (*securedservice.AlsoDoublySecurePayload, error) {
	var (
		payload *securedservice.AlsoDoublySecurePayload
		err     error
	)
	{
		var (
			oauthToken string
			token      string
		)
		{
			md, ok := metadata.FromIncomingContext(ctx)
			if ok {
				if v := md.Get("oauth"); len(v) > 0 {
					oauthToken = v[0]
				}
				if v := md.Get("authorization"); len(v) > 0 {
					token = v[0]
				}
			}
		}
		payload = NewAlsoDoublySecurePayload(message, oauthToken, token)
		if payload.Token != nil {
			if strings.Contains(*payload.Token, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Token, " ", 2)[1]
				payload.Token = &cred
			}
		}
	}
	return payload, err
}

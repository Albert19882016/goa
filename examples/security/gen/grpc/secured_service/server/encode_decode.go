// Code generated by goa v2.0.0-wip, DO NOT EDIT.
//
// secured_service GRPC server encoders and decoders
//
// Command:
// $ goa gen goa.design/goa/examples/security/design -o
// $(GOPATH)/src/goa.design/goa/examples/security

package server

import (
	"context"
	"strings"

	goa "goa.design/goa"
	secured_servicepb "goa.design/goa/examples/security/gen/grpc/secured_service"
	securedservice "goa.design/goa/examples/security/gen/secured_service"
	goagrpc "goa.design/goa/grpc"
	"google.golang.org/grpc/metadata"
)

// EncodeSigninResponse encodes responses from the secured_service signin
// endpoint.
func EncodeSigninResponse(ctx context.Context, v interface{}) (interface{}, error) {
	res, ok := v.(*securedservice.Creds)
	if !ok {
		return nil, goagrpc.ErrInvalidType("secured_service", "signin", "*securedservice.Creds", v)
	}
	resp := NewSigninResponse(res)
	return resp, nil
}

// DecodeSigninRequest decodes requests sent to secured_service signin endpoint.
func DecodeSigninRequest(ctx context.Context, v interface{}) (interface{}, error) {
	var (
		payload *securedservice.SigninPayload
		err     error
	)
	{
		var (
			username string
			password string
		)
		{
			md, ok := metadata.FromIncomingContext(ctx)
			if ok {
				if vals := md.Get("username"); len(vals) == 0 {
					err = goa.MergeErrors(err, goa.MissingFieldError("username", "metadata"))
				} else {
					username = vals[0]
				}
				if vals := md.Get("password"); len(vals) == 0 {
					err = goa.MergeErrors(err, goa.MissingFieldError("password", "metadata"))
				} else {
					password = vals[0]
				}
			}
		}
		message, ok := v.(*secured_servicepb.SigninRequest)
		if !ok {
			return nil, goagrpc.ErrInvalidType("secured_service", "signin", "*secured_servicepb.SigninRequest", v)
		}
		payload = NewSigninPayload(message, username, password)
	}
	return payload, err
}

// EncodeSecureResponse encodes responses from the secured_service secure
// endpoint.
func EncodeSecureResponse(ctx context.Context, v interface{}) (interface{}, error) {
	res, ok := v.(string)
	if !ok {
		return nil, goagrpc.ErrInvalidType("secured_service", "secure", "string", v)
	}
	resp := NewSecureResponse(res)
	return resp, nil
}

// DecodeSecureRequest decodes requests sent to secured_service secure endpoint.
func DecodeSecureRequest(ctx context.Context, v interface{}) (interface{}, error) {
	var (
		payload *securedservice.SecurePayload
		err     error
	)
	{
		var (
			token string
		)
		{
			md, ok := metadata.FromIncomingContext(ctx)
			if ok {
				if vals := md.Get("authorization"); len(vals) == 0 {
					err = goa.MergeErrors(err, goa.MissingFieldError("authorization", "metadata"))
				} else {
					token = vals[0]
				}
			}
		}
		message, ok := v.(*secured_servicepb.SecureRequest)
		if !ok {
			return nil, goagrpc.ErrInvalidType("secured_service", "secure", "*secured_servicepb.SecureRequest", v)
		}
		payload = NewSecurePayload(message, token)
		if strings.Contains(payload.Token, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.Token, " ", 2)[1]
			payload.Token = cred
		}
	}
	return payload, err
}

// EncodeDoublySecureResponse encodes responses from the secured_service
// doubly_secure endpoint.
func EncodeDoublySecureResponse(ctx context.Context, v interface{}) (interface{}, error) {
	res, ok := v.(string)
	if !ok {
		return nil, goagrpc.ErrInvalidType("secured_service", "doubly_secure", "string", v)
	}
	resp := NewDoublySecureResponse(res)
	return resp, nil
}

// DecodeDoublySecureRequest decodes requests sent to secured_service
// doubly_secure endpoint.
func DecodeDoublySecureRequest(ctx context.Context, v interface{}) (interface{}, error) {
	var (
		payload *securedservice.DoublySecurePayload
		err     error
	)
	{
		var (
			token string
		)
		{
			md, ok := metadata.FromIncomingContext(ctx)
			if ok {
				if vals := md.Get("authorization"); len(vals) == 0 {
					err = goa.MergeErrors(err, goa.MissingFieldError("authorization", "metadata"))
				} else {
					token = vals[0]
				}
			}
		}
		message, ok := v.(*secured_servicepb.DoublySecureRequest)
		if !ok {
			return nil, goagrpc.ErrInvalidType("secured_service", "doubly_secure", "*secured_servicepb.DoublySecureRequest", v)
		}
		payload = NewDoublySecurePayload(message, token)
		if strings.Contains(payload.Token, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.Token, " ", 2)[1]
			payload.Token = cred
		}
	}
	return payload, err
}

// EncodeAlsoDoublySecureResponse encodes responses from the secured_service
// also_doubly_secure endpoint.
func EncodeAlsoDoublySecureResponse(ctx context.Context, v interface{}) (interface{}, error) {
	res, ok := v.(string)
	if !ok {
		return nil, goagrpc.ErrInvalidType("secured_service", "also_doubly_secure", "string", v)
	}
	resp := NewAlsoDoublySecureResponse(res)
	return resp, nil
}

// DecodeAlsoDoublySecureRequest decodes requests sent to secured_service
// also_doubly_secure endpoint.
func DecodeAlsoDoublySecureRequest(ctx context.Context, v interface{}) (interface{}, error) {
	var (
		payload *securedservice.AlsoDoublySecurePayload
		err     error
	)
	{
		var (
			oauthToken string
			token      string
		)
		{
			md, ok := metadata.FromIncomingContext(ctx)
			if ok {
				if vals := md.Get("oauth"); len(vals) > 0 {
					oauthToken = vals[0]
				}
				if vals := md.Get("authorization"); len(vals) > 0 {
					token = vals[0]
				}
			}
		}
		message, ok := v.(*secured_servicepb.AlsoDoublySecureRequest)
		if !ok {
			return nil, goagrpc.ErrInvalidType("secured_service", "also_doubly_secure", "*secured_servicepb.AlsoDoublySecureRequest", v)
		}
		payload = NewAlsoDoublySecurePayload(message, oauthToken, token)
		if payload.Token != nil {
			if strings.Contains(*payload.Token, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.Token, " ", 2)[1]
				payload.Token = &cred
			}
		}
	}
	return payload, err
}
